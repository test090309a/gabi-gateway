# gateway/skill_factory.py - Self-Programming Engine für automatische Skill-Erstellung
"""
SkillFactory: Automatische Erstellung von Integrationen basierend auf Anforderungen.
"""
import os
import re
import subprocess
import logging
from pathlib import Path
from typing import Dict, List, Optional, Any
from datetime import datetime

logger = logging.getLogger("GATEWAY.skill_factory")

# Pfade
BASE_DIR = Path(__file__).parent.parent
INTEGRATIONS_DIR = BASE_DIR / "integrations"
TESTS_DIR = BASE_DIR / "tests" / "integrations"
AUTOLEARN_PATH = BASE_DIR / "gateway" / "AUTOLEARN.md"


# Bekannte Library-Mappings
KNOWN_LIBRARIES = {
    "pdf": "PyPDF2",
    "rechnung": "PyPDF2",
    "excel": "openpyxl",
    "spreadsheet": "openpyxl",
    "csv": "pandas",
    "json": "json (stdlib)",
    "xml": "xml.etree.ElementTree (stdlib)",
    "email": "email (stdlib)",
    "imap": "imaplib (stdlib)",
    "smtp": "smtplib (stdlib)",
    "database": "sqlite3 (stdlib)",
    "mysql": "mysql-connector-python",
    "postgres": "psycopg2",
    "mongodb": "pymongo",
    "redis": "redis",
    "api": "requests",
    "http": "requests",
    "web": "requests",
    "websocket": "websockets",
    "telegram": "python-telegram-bot",
    "slack": "slack-sdk",
    "discord": "discord.py",
    "twitter": "tweepy",
    "github": "PyGithub",
    "aws": "boto3",
    "google": "google-api-python-client",
    "cloud": "google-cloud",
    "ai": "openai",
    "ollama": "ollama (stdlib)",
    "llm": "requests",
    "image": "Pillow",
    "bild": "Pillow",
    "video": "opencv-python",
    "audio": "pydub",
    "speech": "SpeechRecognition",
    "ocr": "pytesseract",
    "crypto": "cryptography",
    "encrypt": "cryptography",
    "password": "hashlib (stdlib)",
    "excel": "openpyxl",
    "word": "python-docx",
    "docx": "python-docx",
    "pptx": "python-pptx",
    "zip": "zipfile (stdlib)",
    "tar": "tarfile (stdlib)",
    "ftp": "ftplib (stdlib)",
    "ssh": "paramiko",
    "sftp": "paramiko",
    "calendar": "ics",
    "ical": "ics",
    "rss": "feedparser",
    "sitemap": "beautifulsoup4",
    "scrap": "beautifulsoup4",
    "html": "beautifulsoup4",
    "yaml": "pyyaml",
    "toml": "toml",
    "docker": "docker",
    "k8s": "kubernetes",
    "mqtt": "paho-mqtt",
    "rabbitmq": "pika",
    "sms": "twilio",
    "phone": "twilio",
}


class SkillFactory:
    """
    Self-Programming Engine für automatische Skill-Erstellung.
    """

    def __init__(self):
        self.base_dir = BASE_DIR
        self.integrations_dir = INTEGRATIONS_DIR
        self.tests_dir = TESTS_DIR
        self.autolearn_path = AUTOLEARN_PATH

    def create_skill(self, requirement: str) -> Dict[str, Any]:
        """
        Erstellt einen neuen Skill basierend auf einer Anforderung.

        Workflow:
        1. Identifiziere benötigte Libraries
        2. Installiere Libraries (pip)
        3. Generiere Integration
        4. Generiere Tests
        5. Führe Tests aus
        6. Security Gate Validation
        7. Dokumentiere in AUTOLEARN.md

        Args:
            requirement: Natürlichsprachliche Beschreibung der Anforderung

        Returns:
            Dict mit Erfolgsstatus und Details
        """
        logger.info(f"SkillFactory: Erstelle Skill für '{requirement}'")

        skill_name = self._generate_skill_name(requirement)

        # Schritt 1: Libraries identifizieren
        libraries = self._identify_libraries(requirement)
        logger.info(f"Identifizierte Libraries: {libraries}")

        # Schritt 2: Libraries installieren
        if libraries:
            install_result = self._install_libraries(libraries)
            if not install_result.get("success"):
                return {
                    "success": False,
                    "error": f"Library-Installation fehlgeschlagen: {install_result.get('error')}",
                    "skill_name": skill_name
                }

        # Schritt 3: Integration generieren
        integration_path = self.integrations_dir / f"{skill_name}.py"
        integration_code = self._generate_integration(skill_name, requirement, libraries)

        try:
            integration_path.write_text(integration_code, encoding="utf-8")
            logger.info(f"Integration erstellt: {integration_path}")
        except Exception as e:
            return {
                "success": False,
                "error": f"Fehler beim Schreiben der Integration: {e}",
                "skill_name": skill_name
            }

        # Schritt 4: Tests generieren
        test_path = self.tests_dir / f"test_{skill_name}.py"
        test_code = self._generate_test(skill_name, requirement)

        try:
            # Tests-Verzeichnis sicherstellen
            self.tests_dir.mkdir(parents=True, exist_ok=True)
            test_path.write_text(test_code, encoding="utf-8")
            logger.info(f"Tests erstellt: {test_path}")
        except Exception as e:
            logger.warning(f"Fehler beim Erstellen der Tests: {e}")

        # Schritt 5: Tests ausführen
        test_result = self._run_tests(test_path)
        logger.info(f"Test-Ergebnis: {test_result}")

        # Schritt 6: Security Gate Validation
        security_result = self._security_validate(integration_path)
        if not security_result.get("passed"):
            # Bei Sicherheitsproblemen: Integration löschen
            try:
                integration_path.unlink()
                logger.warning(f"Integration wegen Sicherheitsbedenken gelöscht: {integration_path}")
            except:
                pass

            return {
                "success": False,
                "error": f"Sicherheitsvalidierung fehlgeschlagen: {security_result.get('issues')}",
                "skill_name": skill_name
            }

        # Schritt 7: AUTOLEARN.md aktualisieren
        self._document_skill(skill_name, requirement, libraries, security_result)

        # Schritt 8: Module reload (für dynamische Integration)
        self._reload_modules()

        return {
            "success": True,
            "skill_name": skill_name,
            "integration_path": str(integration_path),
            "test_path": str(test_path),
            "libraries": libraries,
            "security_score": security_result.get("score", 0),
            "test_result": test_result
        }

    def _generate_skill_name(self, requirement: str) -> str:
        """Generiert einen gültigen Python-Modulnamen aus der Anforderung."""
        # Extrahiere Schlüsselwörter
        words = re.findall(r'\b[a-zA-Z]{3,}\b', requirement.lower())

        # Filtere generische Wörter
        stop_words = {"eine", "einen", "einer", "einem", "der", "die", "das", "und", "oder",
                      "ich", "will", "brauche", "möchte", "kann", "soll", "für", "mit", "ohne",
                      "the", "and", "or", "for", "with", "need", "want", "have", "get", "make"}
        words = [w for w in words if w not in stop_words]

        if not words:
            # Fallback: timestamp-basierter Name
            return f"auto_skill_{int(datetime.now().timestamp())}"

        # Nehme die ersten 2-3 relevanten Wörter
        skill_name = "_".join(words[:3])

        # Nur alphanumerisch und underscores
        skill_name = re.sub(r'[^a-z0-9_]', '', skill_name)

        # Keine führenden Zahlen
        if skill_name[0].isdigit():
            skill_name = "auto_" + skill_name

        return skill_name

    def _identify_libraries(self, requirement: str) -> List[str]:
        """
        Identifiziert benötigte Libraries aus der Anforderung.
        """
        requirement_lower = requirement.lower()
        identified = set()

        for keyword, library in KNOWN_LIBRARIES.items():
            if keyword in requirement_lower:
                # Stdlib Libraries nicht installieren
                if "(stdlib)" not in library:
                    identified.add(library)

        return list(identified)

    def _install_libraries(self, libraries: List[str]) -> Dict[str, Any]:
        """
        Installiert benötigte Libraries via pip.
        """
        logger.info(f"Installiere Libraries: {libraries}")

        for library in libraries:
            try:
                result = subprocess.run(
                    ["pip", "install", library, "--quiet"],
                    capture_output=True,
                    text=True,
                    timeout=120
                )

                if result.returncode != 0:
                    logger.warning(f"Library {library} konnte nicht installiert werden: {result.stderr}")

            except Exception as e:
                logger.warning(f"Fehler bei Installation von {library}: {e}")

        return {"success": True, "installed": libraries}

    def _generate_integration(self, skill_name: str, requirement: str, libraries: List[str]) -> str:
        """
        Generiert den Python-Code für die neue Integration.
        """
        # Template für neue Integrationen
        template = f'''# Auto-generierte Integration: {skill_name}
"""
{requirement}

Erstellt: {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}
Libraries: {', '.join(libraries) if libraries else 'None'}
"""
import logging
from typing import Any, Dict, Optional

logger = logging.getLogger("GATEWAY.{skill_name}")

# === KONFIGURATION ===
# Hier können konfigurierbare Parameter definiert werden


class {skill_name.title().replace('_', '')}Integration:
    """
    Auto-generierte Integration für: {requirement}
    """

    def __init__(self):
        self.name = "{skill_name}"
        logger.info(f"Initialisiere {{self.name}} Integration")

    def execute(self, **kwargs) -> Dict[str, Any]:
        """
        Führt die Hauptfunktion aus.

        Args:
            **kwargs: Beliebige Parameter

        Returns:
            Dict mit Ergebnis
        """
        logger.info(f"Execute: {{kwargs}}")

        # === HIER LOGIK IMPLEMENTIEREN ===
        # Beispiel:
        # result = self._do_something(**kwargs)

        return {{
            "status": "success",
            "skill": "{skill_name}",
            "message": "Integration ausgeführt",
            "data": kwargs
        }}

    def _do_something(self, param: str) -> str:
        """Platzhalter für eigentliche Funktionalität."""
        return f"Verarbeite: {{param}}"

    def health_check(self) -> bool:
        """Prüft ob die Integration funktionsbereit ist."""
        return True


# Singleton-Instanz
_integration_instance: Optional[{skill_name.title().replace('_', '')}Integration] = None


def get_integration() -> {skill_name.title().replace('_', '')}Integration:
    """Gibt die Singleton-Instanz zurück."""
    global _integration_instance
    if _integration_instance is None:
        _integration_instance = {skill_name.title().replace('_', '')}Integration()
    return _integration_instance


#便捷 Funktionen für direkten Import
def execute(**kwargs) -> Dict[str, Any]:
    """Führt die Integration direkt aus."""
    return get_integration().execute(**kwargs)


if __name__ == "__main__":
    # Test
    integration = get_integration()
    result = integration.execute(test="value")
    print(result)
'''

        return template

    def _generate_test(self, skill_name: str, requirement: str) -> str:
        """
        Generiert pytest-kompatible Tests.
        """
        class_name = skill_name.title().replace('_', '')

        template = f'''# Auto-generierter Test für {skill_name}
"""
Test für: {requirement}
Erstellt: {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}
"""
import pytest
import sys
from pathlib import Path

# Füge Gateway zum Path hinzu
sys.path.insert(0, str(Path(__file__).parent.parent.parent))


class Test{class_name}:
    """Tests für {skill_name} Integration"""

    @pytest.fixture
    def integration(self):
        """Fixture für die Integration."""
        from integrations.{skill_name} import get_integration
        return get_integration()

    def test_integration_exists(self, integration):
        """Prüft ob Integration existiert."""
        assert integration is not None
        assert integration.name == "{skill_name}"

    def test_execute_returns_dict(self, integration):
        """Prüft ob execute() ein Dict zurückgibt."""
        result = integration.execute()
        assert isinstance(result, dict)

    def test_execute_has_status(self, integration):
        """Prüft ob Ergebnis einen Status hat."""
        result = integration.execute()
        assert "status" in result
        assert result["status"] == "success"

    def test_health_check(self, integration):
        """Prüft Health-Check."""
        assert integration.health_check() is True

    def test_skill_name_in_result(self, integration):
        """Prüft ob Skill-Name im Ergebnis enthalten ist."""
        result = integration.execute()
        assert result.get("skill") == "{skill_name}"


if __name__ == "__main__":
    pytest.main([__file__, "-v"])
'''

        return template

    def _run_tests(self, test_path: Path) -> Dict[str, Any]:
        """
        Führt pytest für die generierten Tests aus.
        """
        if not test_path.exists():
            return {"success": False, "error": "Test-Datei nicht gefunden"}

        try:
            result = subprocess.run(
                ["pytest", str(test_path), "-v", "--tb=short"],
                capture_output=True,
                text=True,
                timeout=60,
                cwd=str(self.base_dir)
            )

            return {
                "success": result.returncode == 0,
                "output": result.stdout,
                "returncode": result.returncode
            }

        except Exception as e:
            return {"success": False, "error": str(e)}

    def _security_validate(self, integration_path: Path) -> Dict[str, Any]:
        """
        Security Gate: Validierung für neue Integrationen.
        """
        from gateway.security_gate import SecurityGate

        gate = SecurityGate()
        result = gate.validate_file(integration_path)

        return result

    def _document_skill(self, skill_name: str, requirement: str,
                       libraries: List[str], security_result: Dict) -> None:
        """
        Dokumentiert den neuen Skill in AUTOLEARN.md.
        """
        entry = f"""
## Skill: {skill_name}
- **Anforderung**: {requirement}
- **Libraries**: {', '.join(libraries) if libraries else 'None'}
- **Erstellt**: {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}
- **Security Score**: {security_result.get('score', 0)}/100
- **Status**: {'✅ Aktiv' if security_result.get('passed') else '❌ Blockiert'}
"""

        try:
            if self.autolearn_path.exists():
                content = self.autolearn_path.read_text(encoding="utf-8")
                # Vor dem letzten Header oder am Ende einfügen
                self.autolearn_path.write_text(content + entry + "\n", encoding="utf-8")
            else:
                # Neue Datei erstellen
                header = "# AUTOLEARN.md\n\n" \
                         "Dokumentation aller Selbsterweiterungen von GABI.\n\n"
                self.autolearn_path.write_text(header + entry + "\n", encoding="utf-8")

            logger.info(f"Skill dokumentiert in AUTOLEARN.md")

        except Exception as e:
            logger.error(f"Fehler beim Dokumentieren: {e}")

    def _reload_modules(self) -> None:
        """
        Versucht importierte Module zu reloaden (für dynamische Integration).
        """
        # Dies ist schwierig in Python - wir protokollieren nur
        logger.info("Module-Reload erfordert Neustart des Gateways")


# Singleton-Instanz
_factory_instance: Optional[SkillFactory] = None


def get_factory() -> SkillFactory:
    """Gibt die Singleton-Instanz der SkillFactory zurück."""
    global _factory_instance
    if _factory_instance is None:
        _factory_instance = SkillFactory()
    return _factory_instance


def create_skill(requirement: str) -> Dict[str, Any]:
    """Shortcut für Skill-Erstellung."""
    return get_factory().create_skill(requirement)
